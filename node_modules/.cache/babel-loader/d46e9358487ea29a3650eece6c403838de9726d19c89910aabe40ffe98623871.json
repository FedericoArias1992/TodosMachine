{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from \"react\";\n//Vamos a usar localstorage para tener persistencia de datos, sin usar base de datos relacional ni no relacionales\n//let stringifiedArray = localStorage.setItem('Version_1', JSON.stringify(array)); //-> para inicializar la version_1 del Localstorage\n//tambien vamos a crear un customhook para manejar todo lo relacionado a localstorage:\n//necesitamos la funcion que actualice el estado de los elementos y a la vez el localstorage tal que exista persistencia de datos\n\nfunction useLocalStorage(initialValue) {\n  _s();\n  const [item, setItem] = useState(initialValue); //asignamos el valor vacio o inicial al estado del customhook\n  const [error, setError] = useState(true); //creamos un estado para saber si hubo o no error en el renderizado\n  useEffect(() => {\n    try {\n      let localstoragedArray = localStorage.getItem('Version_1');\n      let parsedArray;\n      if (!localstoragedArray) {\n        localStorage.setItem('Version_1', JSON.stringify(initialValue)); //si Version_1 (primera vez que se abre la app) = Vacio -> array vacio, pq si no hay que mostrar, la app crashea!\n        parsedArray = [];\n      } else {\n        parsedArray = JSON.parse(localstoragedArray);\n        setItem(parsedArray); //asignamos el valor vacio o inicial al estado del customhook\n      }\n    } catch (error) {\n      setError(false);\n    }\n  }, []);\n\n  //al refrescar la pagina:\n  const saveStateTodos = newTodos => {\n    localStorage.setItem('Version_1', JSON.stringify(newTodos)); //reescribimos el array de todos actualizado\n    setItem(newTodos);\n  };\n  return [item, saveStateTodos, error]; //saveStateTodos es el estados de los array persistente de todos, item es la lista de todos parseada\n} //con esta desestructuracion de arrays como devolucion del customhook, ya podemos usar saveStateTodos()\n_s(useLocalStorage, \"la+KGoNM5BBW3R7xmaZQqEgPs0Y=\");\nexport { useLocalStorage };","map":{"version":3,"names":["useState","useEffect","useLocalStorage","initialValue","_s","item","setItem","error","setError","localstoragedArray","localStorage","getItem","parsedArray","JSON","stringify","parse","saveStateTodos","newTodos"],"sources":["/home/federico/Proyectos/CursosPlatzi/CursoReact/curso-react-intro/src/Hooks/useLocalStorage.js"],"sourcesContent":["import { useState, useEffect } from \"react\";\n//Vamos a usar localstorage para tener persistencia de datos, sin usar base de datos relacional ni no relacionales\n//let stringifiedArray = localStorage.setItem('Version_1', JSON.stringify(array)); //-> para inicializar la version_1 del Localstorage\n//tambien vamos a crear un customhook para manejar todo lo relacionado a localstorage:\n//necesitamos la funcion que actualice el estado de los elementos y a la vez el localstorage tal que exista persistencia de datos\n\nfunction useLocalStorage(initialValue){\n  const [item, setItem] = useState(initialValue); //asignamos el valor vacio o inicial al estado del customhook\n  const [error, setError] = useState(true);     //creamos un estado para saber si hubo o no error en el renderizado\n  useEffect(() => {\n    try {\n      let localstoragedArray = localStorage.getItem('Version_1');\n      let parsedArray;\n      if (!localstoragedArray) {\n        localStorage.setItem('Version_1',JSON.stringify(initialValue));  //si Version_1 (primera vez que se abre la app) = Vacio -> array vacio, pq si no hay que mostrar, la app crashea!\n        parsedArray = [];\n      } else {\n        parsedArray = JSON.parse(localstoragedArray);\n        setItem(parsedArray); //asignamos el valor vacio o inicial al estado del customhook\n      }\n    } catch (error) {\n      setError(false);\n    }\n  }, []);\n\n     //al refrescar la pagina:\n    const saveStateTodos = (newTodos) => {\n      localStorage.setItem('Version_1', JSON.stringify(newTodos));  //reescribimos el array de todos actualizado\n      setItem(newTodos);\n    }\n    return [item, saveStateTodos, error];  //saveStateTodos es el estados de los array persistente de todos, item es la lista de todos parseada\n  }                                 //con esta desestructuracion de arrays como devolucion del customhook, ya podemos usar saveStateTodos()\n  \nexport {useLocalStorage};"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC3C;AACA;AACA;AACA;;AAEA,SAASC,eAAeA,CAACC,YAAY,EAAC;EAAAC,EAAA;EACpC,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGN,QAAQ,CAACG,YAAY,CAAC,CAAC,CAAC;EAChD,MAAM,CAACI,KAAK,EAAEC,QAAQ,CAAC,GAAGR,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAK;EAC9CC,SAAS,CAAC,MAAM;IACd,IAAI;MACF,IAAIQ,kBAAkB,GAAGC,YAAY,CAACC,OAAO,CAAC,WAAW,CAAC;MAC1D,IAAIC,WAAW;MACf,IAAI,CAACH,kBAAkB,EAAE;QACvBC,YAAY,CAACJ,OAAO,CAAC,WAAW,EAACO,IAAI,CAACC,SAAS,CAACX,YAAY,CAAC,CAAC,CAAC,CAAE;QACjES,WAAW,GAAG,EAAE;MAClB,CAAC,MAAM;QACLA,WAAW,GAAGC,IAAI,CAACE,KAAK,CAACN,kBAAkB,CAAC;QAC5CH,OAAO,CAACM,WAAW,CAAC,CAAC,CAAC;MACxB;IACF,CAAC,CAAC,OAAOL,KAAK,EAAE;MACdC,QAAQ,CAAC,KAAK,CAAC;IACjB;EACF,CAAC,EAAE,EAAE,CAAC;;EAEH;EACD,MAAMQ,cAAc,GAAIC,QAAQ,IAAK;IACnCP,YAAY,CAACJ,OAAO,CAAC,WAAW,EAAEO,IAAI,CAACC,SAAS,CAACG,QAAQ,CAAC,CAAC,CAAC,CAAE;IAC9DX,OAAO,CAACW,QAAQ,CAAC;EACnB,CAAC;EACD,OAAO,CAACZ,IAAI,EAAEW,cAAc,EAAET,KAAK,CAAC,CAAC,CAAE;AACzC,CAAC,CAAiC;AAAAH,EAAA,CAzB3BF,eAAe;AA2BxB,SAAQA,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}